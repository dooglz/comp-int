
\documentclass[14pt]{acmsiggraph}
%% all this is for Arial
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{uarial}
\renewcommand{\familydefault}{\sfdefault}
%%%%%%
\usepackage{titlesec}
\usepackage{graphicx}
\graphicspath{{./images/}}

\newcommand{\figuremacroW}[4]{
	\begin{figure}[h] %[htbp]
		\centering
		\includegraphics[width=#4\columnwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure}
}

\newcommand{\figuremacroF}[4]{
	\begin{figure*}[t] % [htbp]
		\centering
		\includegraphics[width=#4\textwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure*}
}

\usepackage{afterpage}
\usepackage{xcolor}
\definecolor{lbcolor}{rgb}{0.98,0.98,0.98}
\usepackage{listings}

\lstset{
	escapeinside={/*@}{@*/},
	language=C++,
	%basicstyle=\small\sffamily,
	%basicstyle=\small\sffamily,	
	basicstyle=\fontsize{8.5}{12}\selectfont,
	%basicstyle=\small\ttfamily,
	%basicstyle=\scriptsize, % \footnotesize,
	%basicstyle=\footnotesize,
	%keywordstyle=\color{blue}\bfseries,
	%basicstyle= \listingsfont,
	numbers=left,
	numbersep=2pt,    
	xleftmargin=2pt,
	%numberstyle=\tiny,
	frame=tb,
	%frame=single,
	columns=fullflexible,
	showstringspaces=false,
	tabsize=4,
	keepspaces=true,
	showtabs=false,
	showspaces=false,
	%showstringspaces=true
	backgroundcolor=\color{lbcolor},
	morekeywords={inline,public,class,private,protected,struct},
	captionpos=t,
	lineskip=-0.4em,
	aboveskip=10pt,
	%belowskip=50pt,
	extendedchars=true,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

\usepackage{lipsum}

\title{Using Evolutionary Algorithms for Job Shop Scheduling}

\author{Sam Serrels\\\ 40082367@napier.ac.uk \\
Edinburgh Napier University\\
Computational Intelligence (SET10107)}
\pdfauthor{Sam Serrels}

\keywords{Evolutionary Algorithms, Genetiv Algorithms, Java, Job Shop}

\begin{document}

\maketitle
\begin{abstract}
	This report documents the implementation and tuning of an Evolutionary Algorithm in Java to solve a set of Job Shop Scheduling Problems. Computing optimal solutions for JSS problems in an NP-Hard task, therefore a brute-force approach is out of the question for problems with large sets of jobs. Evolutionary approaches have been proven to produce good and even optimal solutions in a reactively amount of time, this report implements an EA method using components describes by the literature, and then analyses the solutions produced and the different methods of reaching them.
\end{abstract}

\section{Introduction}
\paragraph{JSSP}
A Job Shop Scheduling Problem is made up of a set of Machines and Jobs, each Job contains a set of operations that must be processed in order and sequentially. The  Operations must be processed by a specific machine, each machine can only process one operation from one job at a time. Each Operation will utilise a machine for a pre-determined amount of time  A solution to the problem takes the form of a list stating the order of operations for each machine so that all jobs are completed in the shortest amount of time possible. This report uses a common simplified version of JSSP wherein each Job has the same amount of operations as there are machines, so that every job will use every machine exactly once.

\paragraph{Encoding for Genetic Evolution}
A solution to a JSSP problem is implemented in code as a 2D array, with each row representing a machine, and each column representing a Job, ordered by the order in which they should be processed. It should be noted that a machine processes an operation, not a job, but as each job only has one operation per machine, the corresponding job can be found trivially and so Job IDs can be used to simplify the implementation. The encoding does not encode the time of execution, only the order.  It is the job of the fitness function when decoding the solution to determine \textit{when} each operation is processed, abiding by the operation prerequisites and machine occupancy constrains. 

\paragraph{Evolving a Solution}
The rows of a solution array form the chromosomes to be processed by the evolutionary algorithm. Each row is a set of all the available Job IDs, and therefore any permutation of this set is a valid solution. 

\paragraph{Comparing solutions}
To obtain a fitness score for a solution, it must be decoded into a final schedule. This process involves determining the start and end time for processing operations on each machine. To do this, the order of operations in the solution is followed for each machine until an operation cannot be scheduled due to a non-complete pre-requite operation, in this case the machine will sit idle until the operation can be processed. Once this process is finished, te total runtime can be determined and used as a fitness value. Other metrics could also be used for fitness (e.g maximum Idle time, or concurrent machine occupancy), but this report only uses runtime to compare solutions.

\section{Previous  Work}
Discuss at least one previous published attempt at solving this or a similar problem. 
Critically comment on the method used and results obtained.
\lipsum[7]
\cite{gonzalez2013efficient}

\cite{gao2011efficient}

\cite{zhang2011effective}

\cite{driss2015effective}

\cite{wang2012new}

\section{Methodology}
Discuss the method(s) that you will use to solve the problem. 
Describe the implementation used and any APIs/Libraries used to assist.
\paragraph{Library Use}
The Implementation was built on top of a provided utility library for generating random solutions, it was also used for solution validating and fitness calculation.\\
The Apache HttpComponents Library, and Google's Gson Library were used in the network distribution code

\subsection{Implementation of Literature}
\lipsum[7]

\subsection{Solution Quality Metrics}
Figure \ref{fig:genalgrunning}
\lipsum[7]

\subsection{Distributed Calibration }
\lipsum[7]


\section{Experiment Plan}
Present an experimental plan to be used to investigate your approach
\lipsum[7]
\subsection{Initial population generation}
A theory that was tested was that if the initial seed population was of a higher quality than a pure random population, then this would increase the efficiency of the overall evolution. Three new algorithms were created and another which generated random solutions and then optimised them with the Feasibility Algorithm were tested.

\paragraph{Job Runtime Priority}
This generation technique ordered jobs by their total runtime, and gave  scheduling priority to the longest running jobs. The theory behind this was that re-arranging smaller operations would always cause less disruption than moving large operations, so it may be beneficial to have the longest running operations in their most optimal place as soon as possible.

\paragraph{Operation Order Priority}
This generation technique attempted to place the first operation of all job first, followed by the second operation of all jobs until all operations were placed. The theory behind this was to aim to reduce machine idle time by reducing instances where operations were scheduled before there prerequisite operations were finished. This follows a similar concept to the feasibility optimisation algortihm, but without attempting to fix dependencies.

\paragraph{Best Random / Best Hybrid}
This solution generator would generate a pool of either random solutions, or solutions created by other generators and return the solution form the pool with the best fitness. The pool size could be adjusted, but it was found that a size of 128 worked best.

\paragraph{Feasibility Optimised}

\lipsum[7]
\subsection{Selection}

\paragraph{Roulette Selection}
\paragraph{Experimental Selection}
Everybody with pairs with everybody above them
\paragraph{Tournament}

\subsection{Crossover}
\paragraph{Single and Multi-Point}
\paragraph{Partially Matched }
\paragraph{Machine Swap}
\paragraph{Partially Matched }
\lipsum[7]
\subsection{Mutation}
\lipsum[7]
\subsection{GE Structure}
\lipsum[7]
\paragraph{Reset operation}
\lipsum[7]
\subsection{Termination Procedure}
\lipsum[7]
\subsection{Distribution}
\lipsum[7]
\subsection{Final adjustments}
\lipsum[7]

\section{Results}
Present your results along with a basic statistical analysis.

\subsection{Feasibility Optimisations}
\figuremacroW
{p100rnd}
{Problem 100, Random Solution}
{Fitness 2471}
{1.0}
\figuremacroW
{p100rndopt}
{Problem 100, Random Solution, Optimised}
{Fitness 1496}
{1.0}


\lipsum[7]
\section{Conclusions}
Critically analyse and reflect on the approach that you have taken. How do your results compare to those published? If your results are not as good as envisaged would you adopt a different approach to solving the problem.

\lipsum[7]

\bibliographystyle{acmsiggraph}
\bibliography{report}


\section{Appendix}
\clearpage
\begin{table}[b]
	{
		\centering
		\resizebox{1.0\textwidth}{!}{
			\begin{minipage}{\textwidth}
				\centering
				\begin{tabular}{p{1.4cm}|cccccccccc}
					Test& 1024 & 2048 & 4096 & 8192 & 16384 & 32768 & 65536 & 131072 & 262144 & 524288\\ \hline \\
					GTX980 512 & 0.233 & 0.321 & 0.652 & 1.145 & 1.974 & 9.219 & 36.789 & 135.558 & 500.509 & 2100.374\\
					GTX980 256 & 0.222 & 0.307 & 0.612 & 1.065 & 1.937 & 9.162 & 34.392 & 134.494 & 489.240 & 2051.084\\
					GTX980 128 & 0.132 & 0.194 & 0.296 & 0.716 & 1.891 & 8.721 & 53.158 & 120.636 & 471.306 & 1902.573\\
					GTX980 64 & 0.132 & 0.172 & 0.277 & 0.645 & 1.862 & 7.259 & 31.745 & 118.255 & 451.687 & 1901.846\\
					GTX980 32 & 0.110 & 0.157 & 0.289 & 0.640 & 1.833 & 7.255 & 28.108 & 116.337 & 451.348 & 1899.133\\
					GTX980 16 & 0.150 & 0.224 & 0.464 & 1.468 & 3.561 & 13.522 & 63.056 & 222.645 & 917.328 & 0.000\\
					\hline\\
					CPU 1 core &  4.898 & 19.137 & 74.248 & 296.022 & 1185.570 & 4798.358 & 19412.055 & 76464.740 & 314798.033 & 1227484.000\\
					CPU 2 cores &  2.510 & 9.825 & 39.221 & 155.133 & 613.820 & 2451.838 & 9838.845 & 40324.536 & 167580.294 & 797311.542\\
					CPU 3 cores &  2.180 & 9.193 & 31.041 & 119.769 & 455.580 & 1821.591 & 7185.361 & 27788.974 & 115910.695 & 496237.950\\
					CPU 4 cores &  1.674 & 7.044 & 22.304 & 98.299 & 410.325 & 1597.991 & 5535.962 & 21020.147 & 95596.342 & 377586.191\\
					CPU 5 cores &  2.018 & 6.930 & 25.998 & 89.877 & 375.376 & 1455.549 & 5624.133 & 22419.623 & 92536.925 & 366961.358\\
					CPU 6 cores &  1.547 & 6.081 & 23.429 & 89.602 & 350.761 & 1350.470 & 5229.090 & 20683.325 & 84305.466 & 350425.495\\
					CPU 7 cores &  1.538 & 5.044 & 20.425 & 82.377 & 322.066 & 1282.543 & 4918.743 & 19273.623 & 78993.126 & 325729.737\\
					CPU 8 cores &  1.674 & 5.106 & 18.330 & 72.642 & 285.565 & 1178.308 & 4643.889 & 18259.532 & 72826.053 & 302954.399\\
					\hline
				\end{tabular}
				
				\caption[Table caption text]{Results of all tests, Times in Milliseconds\\
					}
				\label{table:results}
			\end{minipage} }
		}
	\end{table}

\figuremacroF
{genalgrunning}
{Output from EA}
{Problem 119}
{1.0}
\figuremacroF
{dispatchcmd}
{Console output snippet from Dispatch Server}
{Currently talking to 150 Clients}
{1.0}




\end{document}

