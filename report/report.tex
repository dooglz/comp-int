
\documentclass[14pt]{acmsiggraph}
%% all this is for Arial
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{uarial}
\renewcommand{\familydefault}{\sfdefault}
%%%%%%
\usepackage{titlesec}
\usepackage{graphicx}
\graphicspath{{./images/}}

\newcommand{\figuremacroW}[4]{
	\begin{figure}[h] %[htbp]
		\centering
		\includegraphics[width=#4\columnwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure}
}

\newcommand{\figuremacroF}[4]{
	\begin{figure*}[t] % [htbp]
		\centering
		\includegraphics[width=#4\textwidth]{#1}
		\caption[#2]{\textbf{#2} - #3}
		\label{fig:#1}
	\end{figure*}
}

\usepackage{afterpage}
\usepackage{xcolor}
\definecolor{lbcolor}{rgb}{0.98,0.98,0.98}
\usepackage{listings}

\lstset{
	escapeinside={/*@}{@*/},
	language=C++,
	%basicstyle=\small\sffamily,
	%basicstyle=\small\sffamily,	
	basicstyle=\fontsize{8.5}{12}\selectfont,
	%basicstyle=\small\ttfamily,
	%basicstyle=\scriptsize, % \footnotesize,
	%basicstyle=\footnotesize,
	%keywordstyle=\color{blue}\bfseries,
	%basicstyle= \listingsfont,
	numbers=left,
	numbersep=2pt,    
	xleftmargin=2pt,
	%numberstyle=\tiny,
	frame=tb,
	%frame=single,
	columns=fullflexible,
	showstringspaces=false,
	tabsize=4,
	keepspaces=true,
	showtabs=false,
	showspaces=false,
	%showstringspaces=true
	backgroundcolor=\color{lbcolor},
	morekeywords={inline,public,class,private,protected,struct},
	captionpos=t,
	lineskip=-0.4em,
	aboveskip=10pt,
	%belowskip=50pt,
	extendedchars=true,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

\usepackage{lipsum}

\title{Using Evolutionary Algorithms for Job Shop Scheduling}

\author{Sam Serrels\\\ 40082367@napier.ac.uk \\
Edinburgh Napier University\\
Computational Intelligence (SET10107)}
\pdfauthor{Sam Serrels}

\keywords{Evolutionary Algorithms, Genetiv Algorithms, Java, Job Shop}

\begin{document}

\maketitle
\begin{abstract}
	This report documents the implementation and tuning of an Evolutionary Algorithm in Java to solve a set of Job Shop Scheduling Problems. Computing optimal solutions for JSS problems in an NP-Hard task, therefore a brute-force approach is out of the question for problems with large sets of jobs. Evolutionary approaches have been proven to produce good and even optimal solutions in a reactively amount of time, this report implements an EA method using components describes by the literature, and then analyses the solutions produced and the different methods of reaching them.
\end{abstract}

\section{Introduction}
\paragraph{JSSP}
A Job Shop Scheduling Problem is made up of a set of Machines and Jobs, each Job contains a set of operations that must be processed in order and sequentially. The  Operations must be processed by a specific machine, each machine can only process one operation from one job at a time. Each Operation will utilise a machine for a pre-determined amount of time  A solution to the problem takes the form of a list stating the order of operations for each machine so that all jobs are completed in the shortest amount of time possible. This report uses a common simplified version of JSSP wherein each Job has the same amount of operations as there are machines, so that every job will use every machine exactly once.

\paragraph{Encoding for Genetic Evolution}
A solution to a JSSP problem is implemented in code as a 2D array, with each row representing a machine, and each column representing a Job, ordered by the order in which they should be processed. It should be noted that a machine processes an operation, not a job, but as each job only has one operation per machine, the corresponding job can be found trivially and so Job IDs can be used to simplify the implementation. The encoding does not encode the time of execution, only the order.  It is the job of the fitness function when decoding the solution to determine \textit{when} each operation is processed, abiding by the operation prerequisites and machine occupancy constrains. 

\paragraph{Evolving a Solution}
The rows of a solution array form the chromosomes to be processed by the evolutionary algorithm. Each row is a set of all the available Job IDs, and therefore any permutation of this set is a valid solution. 

\paragraph{Comparing solutions}
To obtain a fitness score for a solution, it must be decoded into a final schedule. This process involves determining the start and end time for processing operations on each machine. To do this, the order of operations in the solution is followed for each machine until an operation cannot be scheduled due to a non-complete pre-requite operation, in this case the machine will sit idle until the operation can be processed. Once this process is finished, te total runtime can be determined and used as a fitness value. Other metrics could also be used for fitness (e.g maximum Idle time, or concurrent machine occupancy), but this report only uses runtime to compare solutions.

\section{Previous  Work}
Discuss at least one previous published attempt at solving this or a similar problem. 
Critically comment on the method used and results obtained.
\figuremacroW
{chart}
{Disjunctive graph of a solution}
{\cite{gao2011efficient}}
{1.0}

\section{Methodology}

\paragraph{Library Use}
The Implementation was built on top of a provided utility library for generating random solutions, it was also used for solution validating and fitness calculation.\\
The Apache HttpComponents Library, and Google's Gson Library were used in the network distribution code

\paragraph{Implementation of Literature}
A mixture of various functions and techniques described by the literature were implemented and the effects of combining them into a working genetic algorithm was recorded.

\subsection{Solution Quality Metrics}
As the Genetic algorithm is running, a method was needed to easily gauge progress and to spot problems. This was achieved by calculating the average fitness of various percentile sections of the population, and printing this to the output every generation along with other statistics like the current best fitness and  best all time fitness.  Divergence is calculated by comparing the average fitness of the entire population compared to same average of the last generation.
Figure \ref{fig:genalgrunning}

\subsection{Initial population generation}
A theory that was tested was that if the initial seed population was of a higher quality than a pure random population, then this would increase the efficiency of the overall evolution. Three new algorithms were created and another which generated random solutions and then optimised them with the Feasibility Algorithm were tested.

\paragraph{Job Runtime Priority}
This generation technique ordered jobs by their total runtime, and gave  scheduling priority to the longest running jobs. The theory behind this was that re-arranging smaller operations would always cause less disruption than moving large operations, so it may be beneficial to have the longest running operations in their most optimal place as soon as possible.

\paragraph{Operation Order Priority}
This generation technique attempted to place the first operation of all job first, followed by the second operation of all jobs until all operations were placed. The theory behind this was to aim to reduce machine idle time by reducing instances where operations were scheduled before there prerequisite operations were finished. This follows a similar concept to the feasibility optimisation algorithm, but without attempting to fix dependencies.

\paragraph{Best Random / Best Hybrid}
This solution generator would generate a pool of either random solutions, or solutions created by other generators and return the solution form the pool with the best fitness. The pool size could be adjusted, but it was found that a size of 128 worked best.

\paragraph{Feasibility Optimised}
In the paper by \cite{wang2012new}, a solution is considered feasible if every operation is scheduled either at the same time or after any prerequisite operations on other machines. In the paper, only solutions that are feasible are considered for fitness calculations. This report implements a method that attempts to turn any solution into a feasible solution, however not all problems can have a feasible solution, and not all solutions can be made 100\% feasible. If only feasible solutions are considered, then the total set of possible solutions is vastly reduced, however the algorithm in this report maintains enough variance that population diversity is still high enough for genetic evolution. 

\figuremacroW
{infeasible}
{Disjunctive graph of an Infeasible solution}
{\cite{wang2012new}}
{1.0}
\figuremacroW
{good}
{Disjunctive graph of the fixed feasible solution}
{Notice how the operation order of the machines never heads to the left\cite{wang2012new}}
{1.0}

This solution uses a modified version of the Best Random generator, where each random solution is optimised before comparison.

\subsection{Selection}
Three different methods of Selection were attempted.

\paragraph{Roulette Selection}
The population is sorted by fitness, the solutions with the best fitness have a higher chance of being selected for crossover.

\paragraph{Experimental Selection}
The population is sorted by fitness, then each solution is paired with all solutions that have a lower fitness than itself.

\paragraph{Tournament}
A random selection of the population is taken, this is then sorted by fitness, and then the best solutions in this pool are paired together for crossover.

\subsection{Crossover}
Five different crossover functions were implemented.
\paragraph{Single and Multi-Point}
A random machine ID is selected from the two solutions and then a crossover point is selected randomly from the list of operations, everything after this point is swapped over from the two solutions. For Multi-point, two random crossover points are selected and everything in-between them is swapped. This can create invalid solutions as there will be duplicate jobs within the job list, there are many different approaches to fixing this, the method used by thids report was to remove the duplicates and fill in the blanks with the missing job operations, ordered by the lowest operation I.

\paragraph{Machine Swap}
This method selects an entire set of operations from a machine and swaps it completely with the list from the corresponding machine in another solution. This has the benefit that a solution will always be valid, but the total amount of unique outcomes  for two input solutions is limited by the number of machines. This is used in the paper by \cite{wang2012new}

\paragraph{Partially Matched }
Two crossover points are selected at and the containing operations are swapped, similar to Multi-Point Crossover. The positions of the operations in each matching swapped sections ar sued to form a lookup table, this is then used to replace duplicate operations.  \cite{sivanandam2007introduction}

\paragraph{Liang Gao}
This crossover follows a method described by \cite{gao2011efficient}. The set of jobs is split randomly into two sets. Jobs in set 1 are copied into the same position in child A as parent 1, and jobs in set 2 are copied into the same position in child B as Parent 2. Then the empty spaces are filled in according to the order of the opposing parent. Child A fills in the empty spaces according to the order of operations from Parent B, and Child B form Parent A. This is demonstrated in Figure \ref{fig:cx}. It is possible in certain situations that a child will be identical to the a parent, so this must be checked for if it is an undesirable outcome.

\figuremacroW
{cx}
{Liang Gao Crossover}
{Notice how Child B is identical to Parent 2}
{1.0}

\subsection{Mutation}
\paragraph {Critical Path Mutation / Local search}
If the critical path of a solution can be determined, the paper by \cite{gao2011efficient} describes a method wherein if two or more on the critical paths are placed consecutively on the same machine, then all permutations of the order of these operations is searched for fitness improvements. This was not implemented in this report as the complexity of determining the critical path was out of the scope of this investigation.

\paragraph{Operation Mutation}
This is theoretically the simplest form of Mutation, a random machine is picked, and then two of the operations within it are swapped. This was the mutation operator used in this investigation.

\subsection{GE Structure}
What happens when new children are returned, do they replace parents, or are they inserted into the population. Does the population size stay the same? Are only new children mutated, or does the entire population have a chance to mutate?

\paragraph{Reset operation}
If the population is seen to converge on a non-optimal solution, then the entire population is mutated and the top solutions are removed. The criterion for initiating a reset could be adjusted beforehand and during the operation of the GE.

\paragraph{Live Parameter adjustment}
Almost all of the parameters within the GA can be altered during runtime, different techniques were tried to couple the live population metrics to the GA parameters, such as increasing the amount of crossovers as overall fitness decreased, or increasing the total population size depending on population diversity.

\subsection{Termination Procedure}
While running an GA indefinitely until a lower bound is reached is a viable approach, this investigation required additional termination events to enable the analysis of the effectiveness of different GA parameters, in order to find the optimal settings for each different JSS problem. The additional termination events were based on: Total Time taken, Generation Count, and Population Diversity.

\subsection{Distribution}
To achieve data for the performance of GA parameters for each supplied JSS problem, the program was distributed over a network of computers. Each computer would ask for a set of parameters from a dispatch server, run the GA with these parameters and then return the results.

\paragraph{Network system design}
For the sake of simplicity the communication protocol used was HTTP, and the data encoding used was JSON. As JSON can easily be converted to and from Java objects. The dispatch server runs a simple HTTP web-server, listening for requests and sending GA parameters (known as WorkOrders in the implementation) to the worker. The worker then returns the result of the GA (WorkResponce) as HTTP POST data. This is stored in a results file by the dispatch server. 

\paragraph{Work Management}
The Dispatch server keeps track of which jobs have been dispatched and not returned, and will remove them from the list if they are not returned within a specific time limit. This means that if a worker crashes or goes offline and does not respond with a result, the same job will be resent to another worker at a later time. Each time a job is dispatched or returned the entire state is saved to disk, this means the dispatch server can be taken down and modified at any time.

\paragraph{Job creation}
The method for determining the parameters to send to a client could include an entirely separate genetic algorithm within itself. This was out of the scope for this project, so a very basic hill-climber approach was implemented. When an request for a job is received, the list of JSS problems is searched to see which has the fewest jobs completed, this is then passed ot a function which generates GA parameters for this problem. This function initially increases the population size and maximum generation limit for each run completed until completing a run would take too long. The next would be to then do a local-search around the best run to determine the best possible parameters for a given JSS problem.




\section{Experiment Plan}
Present an experimental plan to be used to investigate your approach



\section{Results}
Present your results along with a basic statistical analysis.

\subsection{Feasibility Optimisations}
\figuremacroW
{p100rnd}
{Problem 100, Random Solution}
{Fitness 2471}
{1.0}
\figuremacroW
{p100rndopt}
{Problem 100, Random Solution, Optimised}
{Fitness 1496}
{1.0}

\section{Conclusions}
Critically analyse and reflect on the approach that you have taken. How do your results compare to those published? If your results are not as good as envisaged would you adopt a different approach to solving the problem.


\bibliographystyle{acmsiggraph}
\bibliography{report}


\section{Appendix}
\clearpage
\begin{table}[b]
	{
		\centering
		\resizebox{1.0\textwidth}{!}{
			\begin{minipage}{\textwidth}
				\centering
				\begin{tabular}{p{1.4cm}|cccccccccc}
					Test& 1024 & 2048 & 4096 & 8192 & 16384 & 32768 & 65536 & 131072 & 262144 & 524288\\ \hline \\
					GTX980 512 & 0.233 & 0.321 & 0.652 & 1.145 & 1.974 & 9.219 & 36.789 & 135.558 & 500.509 & 2100.374\\
					GTX980 256 & 0.222 & 0.307 & 0.612 & 1.065 & 1.937 & 9.162 & 34.392 & 134.494 & 489.240 & 2051.084\\
					GTX980 128 & 0.132 & 0.194 & 0.296 & 0.716 & 1.891 & 8.721 & 53.158 & 120.636 & 471.306 & 1902.573\\
					GTX980 64 & 0.132 & 0.172 & 0.277 & 0.645 & 1.862 & 7.259 & 31.745 & 118.255 & 451.687 & 1901.846\\
					GTX980 32 & 0.110 & 0.157 & 0.289 & 0.640 & 1.833 & 7.255 & 28.108 & 116.337 & 451.348 & 1899.133\\
					GTX980 16 & 0.150 & 0.224 & 0.464 & 1.468 & 3.561 & 13.522 & 63.056 & 222.645 & 917.328 & 0.000\\
					\hline\\
					CPU 1 core &  4.898 & 19.137 & 74.248 & 296.022 & 1185.570 & 4798.358 & 19412.055 & 76464.740 & 314798.033 & 1227484.000\\
					CPU 2 cores &  2.510 & 9.825 & 39.221 & 155.133 & 613.820 & 2451.838 & 9838.845 & 40324.536 & 167580.294 & 797311.542\\
					CPU 3 cores &  2.180 & 9.193 & 31.041 & 119.769 & 455.580 & 1821.591 & 7185.361 & 27788.974 & 115910.695 & 496237.950\\
					CPU 4 cores &  1.674 & 7.044 & 22.304 & 98.299 & 410.325 & 1597.991 & 5535.962 & 21020.147 & 95596.342 & 377586.191\\
					CPU 5 cores &  2.018 & 6.930 & 25.998 & 89.877 & 375.376 & 1455.549 & 5624.133 & 22419.623 & 92536.925 & 366961.358\\
					CPU 6 cores &  1.547 & 6.081 & 23.429 & 89.602 & 350.761 & 1350.470 & 5229.090 & 20683.325 & 84305.466 & 350425.495\\
					CPU 7 cores &  1.538 & 5.044 & 20.425 & 82.377 & 322.066 & 1282.543 & 4918.743 & 19273.623 & 78993.126 & 325729.737\\
					CPU 8 cores &  1.674 & 5.106 & 18.330 & 72.642 & 285.565 & 1178.308 & 4643.889 & 18259.532 & 72826.053 & 302954.399\\
					\hline
				\end{tabular}
				
				\caption[Table caption text]{Results of all tests, Times in Milliseconds\\
					}
				\label{table:results}
			\end{minipage} }
		}
	\end{table}

\figuremacroF
{genalgrunning}
{Output from EA}
{Problem 119}
{1.0}
\figuremacroF
{dispatchcmd}
{Console output snippet from Dispatch Server}
{Currently talking to 150 Clients}
{1.0}




\end{document}

